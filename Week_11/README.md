学习笔记
# 第一题——分布式锁
## 分析
分布式锁主要要有3个方法
1. 上锁
   1. 上锁时需要检验该锁是否被占用，被占用返回失败
   2. 锁需要加上一个合理的超时时间，以免获取锁程序崩溃导致所没有正常归还
   3. 上锁细化来说需要上锁及设置超时2步
2. 释放锁
   1. 释放锁时需要校验，验证释放的锁是不是自己获取的锁
   2. 释放锁需要校验及释放2步
3. 续命
   1. 鉴于有些任务可能确实执行的比较久，并且业务也知道，所以需要对锁进行续命

## Redis

redis使用唯一线程操作数据库，所以避免了很多并发问题，单个操作绝对能保证原子性。

但是在实现分布式锁时，还是需要注意，不管是上锁还是释放锁都在redis中都需要两步，需要想办法保证这2步要么都完成要么都没完成。比如上锁时，如果应用上了锁，然后挂了，没来的及加超时时间，那么该锁将永远都被占用。又比如在释放锁时，你完成了锁的校验，但在真正释放锁前，你的锁超时了自动释放了，同时又被其他程序上了锁，那么你释放的将会是别人锁

为了能实现这2步的原子性，我们可以使用LUA脚本，在redis中执行LUA脚本是可以保证原子性的

## 实现
[见代码](redis-test/src/main/java/club/gaiaproject/homework/redis/lock/RedisLockUtils.java)

# 第二题——分布式计数器
## 分析
分布式计数器主要有2个方法
1. 加1，redis incr命令
2. 减1，redis decr命令

## 场景
1. 记录每个用户每天访问这个网站的次数
2. 商品限购
3. 限速器

## 实现
[见代码](redis-test/src/main/java/club/gaiaproject/homework/redis/counter/RedisCounterUtils.java) 
# 脑图

[见文件夹](../final)

# JVM

梦开始的地方。

java虚拟机是与之前的C语言核心区别的体现。java编译器将java代码编译成字节码就可以在jvm上运行，不管jvm部署在windows还是linux上，从而实现了跨平台的特性。java的字节码可以使用`javap`命令查看，该层的代码是直接操作内存的更像是是汇编语言。如果熟练掌握对程序逆向、攻防都有相当大的作用。程序要运行必须将字节码加载到内存中，正常是是用默认加载器加载文件，当然我们也可以在代码中使用classLoader手动加载，这时读取的字节码只要最终是合乎规则就行，所以我们可以从网络上，甚至加密的文件中读取代码。

内存是编写程序需要考虑的重要资源之一，了解JVM内存十分重要，核心需要了解线程共享内存是堆，线程不共享的内存栈。以及注意操作系统提供的一块共享内存。栈加载了正在执行的代码。而堆是统一存放对象的地方，也是垃圾回收的目标。java垃圾回收十分重要，主要要记住的核心就是各代GC算法都是为了减少stop-the-word的时间。整体思路是将内存分为年轻代和老年代，年轻代放新生成的对象，老年代放存活久的对象。重点还是要属性各个gc的特点。要熟悉如何看和分析GC日志。

为了监控程序运行的状态，java提供了许多监控运行的工具，工具主要能监控gc的情况，heap内存使用，cpu耗时，线程信息等。最核心的jstat查看gc信息，jmap查看heap或类占用空间统计，jstack看线程信息。图形化的工具主要是jvisualvm。

# NIO

NIO这部分主要是要理解多路复用这种通信模型。NIO在连接建立后会有1个专门的线程管理所有连接，当连接中有数据时再分配一个线程执行数据处理逻辑。然后就是java中对nio封装非常好的一个框架netty，他是许多涉及交互的java大型系统的底层通信框架。了解了netty的主要概念，学习了netty核心是要编写inboud和outboud的处理方法。但离真正掌握netty还是有很长的距离，需要持续时间netty。

# 并发编程

非常值重要！！！配得上3个感叹号。学习java多线程首先要了解线程的状态。核心明白有可运行、正在运行，中断这些状态。要明白java的线程是直接启动的系统级别的线程。要明白多线程相关方法的具体含义，又必须要再自己多练习几次。在多线程的场景自然而然就引出了线程安全的问题。在多个线程同时竞争同一个资源时，如果对资源的访问属性敏感，就称存在竞态条件，导致竞态条件发生的代码区称作临界区。我们需要对临界区加不同的锁或同步机制来控制临界区的执行顺序。我们控制解决并发引起的线程安全问题的主要手段有synchronized、volatile关键字以及Lock对象。

并发编程处理要控制多线程的安全问题，还有一大块是合理的创建多线程，这就涉及到线程池的相关内容。这块就是多练习，实操各种API的使用，熟悉各种线程池的特性，处理练习总结别它法。当然并发编程也会涉及到很多并发并工具类，主要是帮助协调各线程相互协作的，核心都是基于AbstractQueueSynchronizer这个双向队列实现的。还是那句话老师教了很多核心是需要自己练习，融汇掌握。

# Spring 和 ORM 等框架

框架，什么是框架？实现某个业界标准或完成特定基本任务的软件组件规范。他是协助我们更好的解决一类问题的。我们在日常开发中遇到的最最多的就是spring框架。spring可以说是java开发，特别是web业务开发最常用的框架。引入spring意味引入一种协作开发模式。spring重要的两个思想AOP面向切面编程，它的含义是各个业务只需要关注自己核心业务逻辑，其他增强工作都可以交由spring来帮忙织入组织。想web整体的交互逻辑spring已经帮忙设定好，我们只有在关注点加上自己的逻辑就行。而IOC就是依赖注入也是为了能更方面的将切面能更加方便的织入自己的逻辑而设计的。这个功能会帮我们管理创建好的的对象，这样其他对象过程想试用这个对象就不要创建，直接管spring容器要就好了。AOP其实底层是实现代理，就是你调用的其实不是你也得代码，而是spring帮你封装增强过得逻辑，核心就是代理思想的实现。代理实现的方式主要是字节码增强技术，针对接口主要使用默认JDKProxy，proxyTargetClass。非对象主要使用CGlib。对于spring主要要了解bean的生命周期，加载过程，配置方式。通过老师的讲解我也学习到spring发展的重要思路及解决的问题。比如spring boot主要是改变spring的臃肿使用约定大约配置的思想。spring cloud主要是微服务的实现生态。

ORM表示对象关系映射，提供了业务使用数据库的框架，整体解决思路。即通过框架把数据表和java对象关联起来，尽量向使用对象一样使用数据库。ORM实现核心就是Hibernate和mybatis。同时要了解JAVA为我们提供了一套持久化API的抽象，JPA，java persistence api，他是基于ORM的规范，里面由一系类接口和抽象类构成。JPA通过JDK5.0注解描述对象-关系表的映射关系，并提供将运行期的实体对象持久化到数据库中。实现了该套接口其实就涵盖了ORM，就可以像用对象意向操作数据库。其他不说，核心还是自己多练熟悉相关API，熟练使用。java基础开发里还需要属性java8新特性的lambda、stream。lombok和guava可以大大提升开发效率。设计模式是解决问题的最佳实践，这些都是需要深入理解学习的。

# MySQL 数据库和 SQL

程序到底是什么？我认为比较好的解释是算法+数据结构。而数据库是存储数据的，它为我们提供了很多优秀的数据结构以及算法，帮助我们更好的使用管理数据。我认为学习每一种数据库最核心的是了解数据组织方式，这里核心包括如何存储，如何索引。如何索引就直接关系到我们如何插入查询数据。当然剩下还要特别注意的就是mysql事务相关的内容了。在秦老师的带领下我们从数据表设计的入手学习了关系型数据库的设计思想。学习了解了mysql是如何存储数据的，主要是那几类文件。mysql在设计存储和索引上核心的思路是你用A数据那么a附近的数据你也会用到以及磁盘IO是数据库性能的主要瓶颈。老师还带我们学习了mysql数据的插入和查询流程，这对我们深入学习mysql十分有帮助。在课上我们又学习了InnoDB引擎索引数据的方式，B+树，因为这个结构，mysql单表数据最好不要超过2000万。非常感谢老师给我们介绍了mysql配置和调优经验，这些都是需要实打实需要经验积累的。mysql事务也是老师介绍的一个重要部分。这里着重需要将事务和并发合起来理解。事务说白了是保证一组操作的原子性。也是为了应对数据库多线程并发条件下，多线程同时操作数据资源出现的问题。其实这块事务的隔离级别，锁等等概念还不是特别清楚，需要进一步学习巩固。最后关于mysql的就是mysql高可用主从复制读写分离的东西了，这点主要思路是把单机mysql变为集群的。

# 分库分表

分库分表，主要针对的问题是当业务飞快发展，数据量指数级上升的情况下，如何使用数据库的问题。基本思路就是分库分表。拆分主要分为横向拆分和纵向拆分。横向查分就是就是将数据按照一定逻辑落到不同的库表中，拆分主要需要一个字段，可以是id mod上N，可以是时间，也可以是根据用户，1个用户的所用数据放到一类库中。而纵向拆分主要是拆服务。大表宽表变成小表，这在查询中一般需要做更多的操作。针对分开分别老师主要向我们介绍了拆分逻辑。同时给我们详细介绍里可以实现拆分的数据库中间件，让我们了解了这部分未来发展的方向。在分库分表这部分自然的就带出了分布式事务，核心问题是怎么保证不同系统一系列操作的原子性。主要2个方向，把数据组织起来从数据库的层面实现事务，但是这个比较麻烦是强一致性的。我个人会比较推荐考虑柔性事务，只求最终一致性，性能有不少提升，柔性事务里TCC模型我认为是比较好的，我会重点理解。

# RPC 和微服务
微服务RPC这块特别感谢秦老师带我们学习了远程过程调用RPC的核心思路。说白了就是怎么向调自己内部服务一样调用远端的服务。基于这个目的老师介绍了整个的核心流程。然后老师介绍了从RPC走向了面向服务化的架构SOA。各个业务都是内聚的向外提供接口的服务，开发是面向服务提以供服务的目的。可以说RPC是SOA的基础，但是SOA有远不止这些。SOA我认为也是有2个思路，一个是之前的ESB，是由中心的，所有服务都连接到esb上，所有服务获取也是从esb上获取。第二个就是我们常提的微服务。微服务的服务之间是直接通信的，但是会有很多中间外围的组件做一些统一的治理工作，比如注册中心，配置中心，网关等。而我们的dubbo我认为更多的是RPC框架，封装了底层的通信。同时他能接入很多服务中间件，比如zookeeper作为注册中心等。可以将单个服务配置成多个实现负载均衡路由治理等。在dubbo中服务之间的通信是自己实现的协议。而spring cloud也作为一套微服务生态他默认底层通信就是http，在生态能我们可以快速接入网关，配置中心，链路检测等一系列服务治理的功能。对底层实现的了解还是多练。为了服务的发展方向是服务网格和服务单元。将服务间的网络通信及控制策略下沉到基础设施就形成了所谓的服务网格，通过微服务、容器化、持续交付、devops等技术组成了所谓的云原生体系。单元化的架构是以单元组织架构，以单元化部署为调度单位。每个单元五脏俱全，仅仅是只能操作一部分数据而已。

# 分布式缓存

为了提升速度，我们需要将常用的数据做到缓存里。首先老师向我们介绍了缓存的本质，就是系统各级处理速度不匹配，利用空间换时间。其实并不是所有数据都适合放到缓存中，只有变动频率不大、一致性要求不高的数据才适合放在缓存中。如何评判呢主要就是读写比，读远远大于写操作以及命中率，它体现了缓存的数据是否有价值。在加载缓存的逻辑其实也有两大类，启动全加载以及懒加载，先看缓存是否有数据，没数据读数据库。以及缓存中没数据就直接返回没数据，然后刷新缓存策略可以周期执行也可以异步执行。然后老师着重介绍了缓存使用不当可能出现的问题1、导致系统预热过慢；2、过多加载数据导致系统内存资源耗尽。3、大量并发查询不存在的key，导致压力直接穿透到数据库（缓存穿透）。4、缓存击穿，某个key失效但正好有大量并发请求访问这个可以。5、雪崩，某一时刻缓存大量失效，大量请求进来直接打到数据库上。缓存我们可以使用本地缓存，就是创建个map对象或guava cache。其实我们更加常用的是使用redis做缓存即远程缓存。

redis，最常用的外部缓存，老师带我们梳理了5大基础结构，3大高级结构。以及6大使用场景，这些都是十分精炼的经验，非常感谢老师。其实redis的核心是他操作数据是单线程的，保证了每个命令天然是原子性的。基于这个特性就派生除了redis的各种使用场景（key-value数据不用考虑单个命令加锁）。然后是基于redis的工具包重点学习redission。redis如此常用于数据库一样也需要考虑部署为集群。redis可以部署主从，高可用可以加上哨兵机制，自动选主以及集群模式，数据按分区存储在不同的机器上。最后老师点了1下内存网格，核心思路就是将多机的内存打通，一起存数据。内存网格的插件是Hazelcast。

# 分布式消息队列

消息队列主要解决的是系统间通信的问题其次还能解决系统解耦，请求削峰。其实业界对消息队列对是有统一的抽象的，java的JMS接口，AMQP协议。核心的抽象都有exchange，queue，dispatch。然后老师按代介绍了3代消息队列，以及没代主要解决的问题。其实我们最常见用起来最爽的是二代的kafka，思考起来，它的亮点是1、数据落地了2、性能不好的集群也能做节点，横向扩展能力好。3、模型比较简单且基本够用。4、吞吐量高。在使用消息队列时我们要重点注意3个队列语义，At most once 至多一次。At least once至少一次。Exactily once，精确一次。2个最主要的消息处理模式，点对点以及发布订阅。在学习每个组件时注意判断如何实现这3中语义以及各个组件是如何实现这2中模式。